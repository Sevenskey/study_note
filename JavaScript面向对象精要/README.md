# 原始类型和引用类型

Javascript有两种基本数据类型：**原始类型**和**引用类型**。

## 原始类型

原始类型保存为简单数据值，它被直接保存在变量对象内。

Javascript有五种原始类型：**boolean**, **number**, **string**, **null**（空类型，只有一个值：null）, **undefined**（未定义，只有一个值：undefined）

### 鉴别

鉴别原始类型的最佳方法是使用**typeof**操作符。

对于`typeof null`，其运行结果是`"object"`，所以判断一个值是否为空类型的最佳方法是直接和null进行比较：`console.log(value === null)`。（进行这样的比较时要使用三等号，因为`console.log(value == null) //true`。）

### 原始方法

sting, number, boolean虽然不是对象，但是也拥有方法。

## 原始封装类型

Javascript中共有三种原始封装类型：**String**, **Number**, **Boolean**。这些特殊的引用类型的存在使得原始类型使用起来和对象一样方便。

当读取字符串、数字或布尔值时，原始封装类型将被自动创建。当该原始封装类型的对象被使用过后就会被立刻销毁。即在每次对原始类型进行读取时都会创建一个该原始类型的对象，当该次读取结束后这个临时对象会被立即销毁。

虽然原始封装类型会被自动创建，在这些值上进行instanceof检查对应类型的返回值却都是false。这是因为临时对象仅在被读取时创建，instanceof操作符并没有真的读取任何东西。

手动创建原始封装类型实际会创建出一个`object`，这意味着`typeof`无法鉴别出你实际保存的数据的类型。另外，如果使用创建原始封装类型的方式创建`Boolean`对象，对象的值是`false`，但它在条件判断语句中会被认为是`true`，因为**一个对象在条件判断语句中总被认为是`true`**。

## 引用类型

**引用类型保存为对象**，其本质是指向内存位置的引用，即作为一个指针保存在变量对象内，该指针指向实际对象在内存中的存储位置。

**引用类型不在变量中直接保存对象**，而是一个指向内存中实际对象所在位置的指针（或者说引用）。当你将一个对象赋给变量时，实际是**赋值给这个变量一个指针**，即，将一个变量赋值给另一个变量时，两个变量各获得了一份指针的拷贝，指向内存中的同一个对象。

（**关于传值与传址** 首先明确，在Javascript中只有传值行为。要理解引用类型的传值行为（一般会被误解为传址），应先明确真正的传址行为。传址是指**传递某个变量本身的地址**。而Javascript中引用类型的传递行为是**将当前变量的内容进行传递（拷贝）**，而此内容是该引用类型值的地址。）

Javascript有六种内建类型：**Object**, **Array**, **Date**, **Error**, **Function**, **RegExp**。

引用值是引用类型的实例，也是对象的同义词。

如果某对象的属性的值是函数，它就被称为方法。

在使用对象前，必须先创建它们。

任何函数都可以是构造函数。

###字面形式

字面形式允许你再不需要使用new操作符和构造函数显式创建对象的情况下生成引用值。定义函数式多用字面形式。定义正则表达式时使用字面形式可以不需要担心字符串中的转义字符。

### 对象引用解除

最好在不使用对象时将其引用解除。解除引用的最佳手段是将对象变量置为null。当内存中的对象不再被引用后，垃圾收集器会把那块内存挪作他用。

### 鉴别

对于所有非函数的引用类型，typeof返回"object"。此时可以使用`instanceof`操作符来鉴别继承类型。

可以发现，**所有对象都是Object的实例**。

虽然`instanceof`可以鉴别数组，但是由于每一个页面都拥有自己的全局上下文，当把一个数组从一个框架传到另一个框架时，`instanceof`就无法识别它，因为那个数组是来自不同框架的Array的实例。所以可以使用`Array.isArray()`来明确鉴别一个值是否为Array的实例。IE8或更早版本不支持该方法。

### 访问属性

可以使用点号和中括号访问对象属性。如果需要动态决定访问哪个属性时，或是属性名称中含有空格等特殊字符时，应使用中括号的方式来访问。

## 总结

- 每个变量或数据都有一个对应的原始类型或引用类型。
- 五种原始类型的值会被直接保存在变量对象中。（背包存在变量对象中，但它们本身不是对象）
- 对象是引用类型的实例。
- 为了让原始类型看上去更像引用类型，Javascript提供了三种原始封装类型。


# 函数

是函数不同于其它对象的决定性特点是函数存在一个被称为`[[Call]]`的内部属性。**内部属性无法通过代码访问而是定义了代码执行时的行为**。

`typeof`对任何具有`[[Call]]`属性的对象返回"function"。

## 定义函数

1. **函数声明** 以`function`关键字为开头，后面跟着函数名称。函数的内容放在大括号内。

2. **函数表达式** `function`关键字后不需要加上函数的名字。这种函数被称为匿名函数，因为函数对象本身没有名字。取而代之的函数表达式通常会被一个**变量或属性**引用。

**注意** 函数声明会被提升至上下文（作用域）的顶部。

## 特点

函数可以被当成参数传递给别的函数，或从别的函数中返回。基本上只要是可以使用其他引用值的地方，你就可以使用函数。

## 参数

你可以给函数传递任意数量的参数却不造成错误。

函数参数实际上被保存在一个被称为arguments的类似数组的对象中。`arguments`对象自动存在于函数中。

**注意** `arguments`对象不是一个数组的实例。其拥有的方法与数组不同,`Array.isArray(arguments)`永远返回`false`。

没有重载。所以可以使用检查arguments的长度的方式，搭配`typeof`和`instanceof`来模仿重载。

## 对象方法

如果属性的值是函数，则该属性被称为方法。

### this 对象

JavaScript 所有的函数作用域内部都有一个`this`对象代表调用该函数的对象。在全局作用域中，`this`代表全局对象（浏览器里的`window`）。当一个函数作为对象的方法被调用时，默认`this`的值等于那个对象。

### 改变 this

函数会在各种不同的上下文中被使用。一般`this`会被自动设置，但是你可以改变它的值来完成不同的目标。有三种函数方法允许你改变`this`的值。

#### call()方法

可以显式指定`this`的值。第一个参数会代替使用该方法的函数中的`this`。

#### apply()方法

只接受两个参数，第二个参数是参数数组。其余和`call()`方法表现一致。

#### bind()方法

第一个参数是要传给新函数的`this`的值，其他所有参数代表需要被永久设置在新函数中的命名参数。并且使用这个方法时函数不会被执行。如果要在使用的同时执行它需要在后面加一对括号。

## 总结

JavaScript 中的函数和其他对象最大的区别在于它们有一个特殊的内部属性`[[Call]]`，包含了该函数的执行指令。`typeof`操作符会在对象内查找这个属性，如果找到，它会返回“function”。


